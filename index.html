<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Knee Angle Tracker</title>
<style>
body {
  margin:0;
  overflow:hidden;
  background:black;
  touch-action:none;
}
#video {
  position:absolute;
  top:0; left:0;
  width:100vw; height:100vh;
  object-fit:cover;
  z-index:0;
}
#canvas {
  position:absolute;
  top:0; left:0;
  z-index:1;
}
#angleLabel {
  position:absolute;
  top:20px;
  width:100vw;
  text-align:center;
  font-size:36px;
  font-weight:700;
  padding:10px 0;
  color:white;
  background:rgba(0,0,0,0.5);
  border-radius:8px;
  z-index:2;
}
#btnPanel {
  position:absolute;
  bottom:120px;
  width:100vw;
  display:flex;
  justify-content:center;
  flex-wrap:wrap;
  gap:16px;
  z-index:3;
}
#btnPanel button {
  padding:18px 30px;
  font-size:26px;
  border-radius:12px;
  min-width:160px;
  background:#222;
  color:white;
  border:2px solid #555;
}
#startPanel {
  position:absolute;
  bottom:20px;
  width:100vw;
  display:flex;
  justify-content:center;
  z-index:3;
}
#startPanel button {
  padding:18px 32px;
  font-size:28px;
  font-weight:600;
  border-radius:12px;
  min-width:240px;
  background:#0066ff;
  color:white;
  border:none;
}
</style>
</head>
<body>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>
<div id="angleLabel">Angle: --째</div>

<div id="btnPanel">
  <button id="fixBtn">Fix</button>
  <button id="snapBtn">Snap</button>
  <button id="resetBtn">Reset</button>
  <button id="flipBtn">Flip</button>
</div>

<div id="startPanel">
  <button id="startBtn">Start Camera</button>
</div>

<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
const video=document.getElementById("video");
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
const angleLabel=document.getElementById("angleLabel");

const startBtn=document.getElementById("startBtn");
const fixBtn=document.getElementById("fixBtn");
const resetBtn=document.getElementById("resetBtn");
const snapBtn=document.getElementById("snapBtn");
const flipBtn=document.getElementById("flipBtn");

let points=[];
let dragging=null;
let tracking=false;

let videoInputs=[];
let currentCam=0;
let stream=null;

let cap=null, grayPrev=null, grayCurr=null, pPrev=null;
let angleSmooth=null;
const alpha=0.25;
let lastAngleUpdate=0;
const angleCooldown=500; //ms

// ------- Timestamp name --------
function timestampName() {
  const d = new Date();
  const pad = (n)=> n.toString().padStart(2,'0');
  return `knee_${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}.png`;
}

// ------- Camera ---------
async function listCams(){
  const dev=await navigator.mediaDevices.enumerateDevices();
  videoInputs=dev.filter(d=>d.kind==="videoinput");
  videoInputs.sort((a,b)=>b.label.toLowerCase().includes("back") - a.label.toLowerCase().includes("back"));
}
async function startCam(){
  if(stream) stream.getTracks().forEach(t=>t.stop());
  const id=videoInputs[currentCam]?.deviceId;
  stream = await navigator.mediaDevices.getUserMedia({video:{deviceId:{exact:id}},audio:false});
  video.srcObject=stream;
}
flipBtn.onclick=()=>{
  if(videoInputs.length>1){
    currentCam=(currentCam+1)%videoInputs.length;
    startCam();
  }
};
startBtn.onclick=async()=>{
  await listCams();
  await startCam();
};

// ------ Canvas -------
function resize(){
  canvas.width=innerWidth;
  canvas.height=innerHeight;
}
resize();
onresize=resize;

// ----- Angle math -----
function calcAngle(A,B,C){
  const v1={x:A.x-B.x,y:A.y-B.y};
  const v2={x:C.x-B.x,y:C.y-B.y};
  const dot=v1.x*v2.x+v1.y*v2.y;
  const m1=Math.hypot(v1.x,v1.y);
  const m2=Math.hypot(v2.x,v2.y);
  return Math.acos(dot/(m1*m2))*180/Math.PI;
}

// ----- Touch -----
function getTouch(e){
  const t=e.touches[0];
  return{x:t.clientX,y:t.clientY};
}
canvas.addEventListener("touchstart",e=>{
  if(tracking) return;
  const p=getTouch(e);
  for(let q of points) if(Math.hypot(p.x-q.x,p.y-q.y)<35){ dragging=q; return; }
  if(points.length<3){
    const L=["A","B","C"];
    points.push({x:p.x,y:p.y,label:L[points.length]});
  }
});
canvas.addEventListener("touchmove",e=>{
  if(tracking) return;
  if(dragging){
    const p=getTouch(e);
    dragging.x=p.x; dragging.y=p.y;
  }
});
canvas.addEventListener("touchend",()=> dragging=null);

// ----- Fix -> Track -----
fixBtn.onclick=()=>{
  if(points.length!==3 || tracking) return;
  tracking=true;
  cap=new cv.VideoCapture(video);
  grayPrev=new cv.Mat(); grayCurr=new cv.Mat();
  pPrev=cv.matFromArray(3,1,cv.CV_32FC2,points.flatMap(p=>[p.x,p.y]));
};

// ----- Reset -----
resetBtn.onclick=()=>{
  tracking=false;
  points=[];
  angleSmooth=null;
  angleLabel.textContent="Angle: --째";
};

// ----- Snapshot -----
snapBtn.onclick=()=>{
  const sc=document.createElement("canvas");
  sc.width=canvas.width; sc.height=canvas.height;
  const sctx=sc.getContext("2d");
  sctx.drawImage(video,0,0,canvas.width,canvas.height);
  sctx.drawImage(canvas,0,0);

  sctx.font="36px sans-serif";
  sctx.fillStyle="white";
  sctx.fillText(angleLabel.textContent,canvas.width/2-150,50);

  const a=document.createElement("a");
  a.href=sc.toDataURL();
  a.download=timestampName();
  a.click();
};

// ----- Render -----
function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  if(!tracking){
    if(points.length){
      for(let p of points){
        ctx.fillStyle="red"; ctx.beginPath();
        ctx.arc(p.x,p.y,14,0,2*Math.PI); ctx.fill();
        ctx.fillStyle="white"; ctx.font="28px sans-serif";
        ctx.fillText(p.label,p.x+20,p.y+10);
      }
    }
    if(points.length===3){
      ctx.strokeStyle="yellow"; ctx.lineWidth=5;
      ctx.beginPath();
      ctx.moveTo(points[0].x,points[0].y);
      ctx.lineTo(points[1].x,points[1].y);
      ctx.lineTo(points[2].x,points[2].y);
      ctx.stroke();
      angleLabel.textContent="Angle: "+calcAngle(points[0],points[1],points[2]).toFixed(1)+"째";
    }
    return requestAnimationFrame(render);
  }

  let frame=new cv.Mat(canvas.height,canvas.width,cv.CV_8UC4);
  cap.read(frame);
  cv.cvtColor(frame,grayCurr,cv.COLOR_RGBA2GRAY);

  if(grayPrev.cols>0){
    let pNext=new cv.Mat(),st=new cv.Mat(),err=new cv.Mat();
    cv.calcOpticalFlowPyrLK(grayPrev,grayCurr,pPrev,pNext,st,err,{winSize:new cv.Size(15,15)});
    let arr=pNext.data32F;
    points=[ {x:arr[0],y:arr[1],label:"A"},
             {x:arr[2],y:arr[3],label:"B"},
             {x:arr[4],y:arr[5],label:"C"} ];
    let ang=calcAngle(points[0],points[1],points[2]);
    angleSmooth=(angleSmooth==null)?ang:alpha*ang+(1-alpha)*angleSmooth;
    let now=performance.now();
    if(now-lastAngleUpdate>angleCooldown){
      angleLabel.textContent="Angle: "+angleSmooth.toFixed(1)+"째";
      lastAngleUpdate=now;
    }
    pPrev=pNext;
  }

  for(let p of points){
    ctx.fillStyle="red"; ctx.beginPath();
    ctx.arc(p.x,p.y,14,0,2*Math.PI); ctx.fill();
    ctx.fillStyle="white"; ctx.font="26px sans-serif";
    ctx.fillText(p.label,p.x+18,p.y+10);
  }

  ctx.strokeStyle="yellow"; ctx.lineWidth=5;
  ctx.beginPath();
  ctx.moveTo(points[0].x,points[0].y);
  ctx.lineTo(points[1].x,points[1].y);
  ctx.lineTo(points[2].x,points[2].y);
  ctx.stroke();

  grayCurr.copyTo(grayPrev);
  frame.delete();
  requestAnimationFrame(render);
}

function wait(){ if(typeof cv==='undefined') requestAnimationFrame(wait); else requestAnimationFrame(render); }
wait();
</script>
</body>
</html>
