<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Knee Angle Tracker</title>
<style>
body {
  margin:0;
  overflow:hidden;
  background:black;
  touch-action:none;
}
#video {
  position:absolute;
  top:0; left:0;
  width:100vw; height:100vh;
  object-fit:cover;
}
#canvas {
  position:absolute;
  top:0; left:0;
}
#angleLabel {
  position:absolute;
  top:20px;
  width:100vw;
  text-align:center;
  font-size:38px;
  font-weight:700;
  padding:14px 0;
  color:white;
  background:rgba(0,0,0,0.55);
  border-radius:8px;
  z-index:3;
}
#btnPanel {
  position:absolute;
  bottom:120px;
  width:100vw;
  display:flex;
  justify-content:center;
  flex-wrap:wrap;
  gap:18px;
  z-index:4;
}
#btnPanel button {
  padding:20px 32px;
  font-size:28px;
  font-weight:600;
  border-radius:12px;
  min-width:170px;
  background:#222;
  color:white;
  border:2px solid #555;
}
#startPanel {
  position:absolute;
  bottom:22px;
  width:100vw;
  display:flex;
  justify-content:center;
  z-index:5;
}
#startPanel button {
  padding:22px 34px;
  font-size:30px;
  font-weight:700;
  border-radius:12px;
  min-width:260px;
  background:#0070ff;
  color:white;
  border:none;
}
</style>
</head>
<body>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>
<div id="angleLabel">Angle: --째</div>

<div id="btnPanel">
  <button id="fixBtn">Fix</button>
  <button id="snapBtn">Snap</button>
  <button id="resetBtn">Reset</button>
  <button id="flipBtn">Flip</button>
</div>

<div id="startPanel">
  <button id="startBtn">Start Camera</button>
</div>

<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
const video=document.getElementById("video");
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
const angleLabel=document.getElementById("angleLabel");

const startBtn=document.getElementById("startBtn");
const fixBtn=document.getElementById("fixBtn");
const resetBtn=document.getElementById("resetBtn");
const snapBtn=document.getElementById("snapBtn");
const flipBtn=document.getElementById("flipBtn");

// ---- State ----
let placement=true;
let tracking=false;
let points=[];
let dragging=null;

// ---- Camera ----
let videoInputs=[];
let currentCam=0;
let stream=null;

// ---- LK Tracking ----
let cap=null, grayPrev=null, grayCurr=null, pPrev=null;
let angleSmooth=null;
const alpha=0.25;
let lastAngleUpdate=0;
const angleCooldown=500;

// ---- Filename ----
function timestampName(){
  const d=new Date();
  const pad=n=>n.toString().padStart(2,'0');
  return `knee_${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}.png`;
}

// ---- Camera Handling ----
async function listCams(){
  const dev=await navigator.mediaDevices.enumerateDevices();
  videoInputs=dev.filter(d=>d.kind==="videoinput");
  videoInputs.sort((a,b)=>b.label.toLowerCase().includes("back")-a.label.toLowerCase().includes("back"));
}
async function startCam(){
  if(stream) stream.getTracks().forEach(t=>t.stop());
  const id=videoInputs[currentCam].deviceId;
  stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:{exact:id}},audio:false});
  video.srcObject=stream;
}
flipBtn.onclick=()=>{
  if(videoInputs.length>1){
    currentCam=(currentCam+1)%videoInputs.length;
    startCam();
  }
};
startBtn.onclick=async()=>{
  await listCams();
  await startCam();
};

// ---- Canvas ----
function resize(){
  canvas.width=innerWidth;
  canvas.height=innerHeight;
}
resize(); onresize=resize;

// ---- Angle ----
function calcAngle(A,B,C){
  const v1={x:A.x-B.x,y:A.y-B.y};
  const v2={x:C.x-B.x,y:C.y-B.y};
  const dot=v1.x*v2.x+v1.y*v2.y;
  const m1=Math.hypot(v1.x,v1.y);
  const m2=Math.hypot(v2.x,v2.y);
  return Math.acos(dot/(m1*m2))*180/Math.PI;
}

// ---- Touch Placement ----
function getTouch(e){
  const t=e.touches[0];
  return{x:t.clientX,y:t.clientY};
}

canvas.addEventListener("touchstart",e=>{
  if(!placement) return;
  const p=getTouch(e);
  for(let q of points){
    if(Math.hypot(p.x-q.x,p.y-q.y)<35){ dragging=q; return; }
  }
  if(points.length<3){
    const L=["A","B","C"];
    points.push({x:p.x,y:p.y,label:L[points.length]});
  }
});
canvas.addEventListener("touchmove",e=>{
  if(!placement) return;
  if(dragging){
    const p=getTouch(e);
    dragging.x=p.x; dragging.y=p.y;
  }
});
canvas.addEventListener("touchend",()=> dragging=null);

// ---- Fix -> Start Tracking ----
fixBtn.onclick=()=>{
  if(points.length!==3 || tracking) return;
  placement=false;
  tracking=true;
  cap=new cv.VideoCapture(video);
  grayPrev=new cv.Mat();
  grayCurr=new cv.Mat();
  pPrev=cv.matFromArray(3,1,cv.CV_32FC2,points.flatMap(p=>[p.x,p.y]));
};

// ---- Reset -> Back to Placement ----
resetBtn.onclick=()=>{
  tracking=false;
  placement=true;
  points=[];
  dragging=null;
  angleSmooth=null;
  lastAngleUpdate=0;
  pPrev=null;
  grayPrev=null;
  grayCurr=null;
  cap=null;
  angleLabel.textContent="Angle: --째";
};

// ---- Snapshot ----
snapBtn.onclick=()=>{
  const sc=document.createElement("canvas");
  sc.width=canvas.width; sc.height=canvas.height;
  const sctx=sc.getContext("2d");
  sctx.drawImage(video,0,0,canvas.width,canvas.height);
  sctx.drawImage(canvas,0,0);
  sctx.font="38px sans-serif";
  sctx.fillStyle="white";
  sctx.fillText(angleLabel.textContent,canvas.width/2-160,60);
  const a=document.createElement("a");
  a.href=sc.toDataURL();
  a.download=timestampName();
  a.click();
};

// ---- Render ----
function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // ---- Placement Mode ----
  if(placement && !tracking){
    if(points.length===3){
      ctx.strokeStyle="yellow"; ctx.lineWidth=5;
      ctx.beginPath();
      ctx.moveTo(points[0].x,points[0].y);
      ctx.lineTo(points[1].x,points[1].y);
      ctx.lineTo(points[2].x,points[2].y);
      ctx.stroke();
      angleLabel.textContent="Angle: "+calcAngle(points[0],points[1],points[2]).toFixed(1)+"째";
    }
    for(let p of points){
      ctx.fillStyle="red"; ctx.beginPath();
      ctx.arc(p.x,p.y,14,0,2*Math.PI); ctx.fill();
      ctx.fillStyle="white"; ctx.font="28px sans-serif";
      ctx.fillText(p.label,p.x+18,p.y+10);
    }
    return requestAnimationFrame(render);
  }

  // ---- Tracking Mode ----
  if(tracking){
    let frame=new cv.Mat(canvas.height,canvas.width,cv.CV_8UC4);
    cap.read(frame);
    cv.cvtColor(frame,grayCurr,cv.COLOR_RGBA2GRAY);

    // If first frame after FIX -> draw manual + initialize prev
    if(!grayPrev.cols){
      for(let p of points){
        ctx.fillStyle="red"; ctx.beginPath();
        ctx.arc(p.x,p.y,14,0,2*Math.PI); ctx.fill();
      }
      ctx.strokeStyle="yellow"; ctx.lineWidth=5;
      ctx.beginPath();
      ctx.moveTo(points[0].x,points[0].y);
      ctx.lineTo(points[1].x,points[1].y);
      ctx.lineTo(points[2].x,points[2].y);
      ctx.stroke();
      grayCurr.copyTo(grayPrev);
      frame.delete();
      requestAnimationFrame(render);
      return;
    }

    // LK update
    let pNext=new cv.Mat(),st=new cv.Mat(),err=new cv.Mat();
    cv.calcOpticalFlowPyrLK(grayPrev,grayCurr,pPrev,pNext,st,err,{winSize:new cv.Size(15,15)});
    let arr=pNext.data32F;
    points=[
      {x:arr[0],y:arr[1],label:"A"},
      {x:arr[2],y:arr[3],label:"B"},
      {x:arr[4],y:arr[5],label:"C"},
    ];

    let ang=calcAngle(points[0],points[1],points[2]);
    angleSmooth=(angleSmooth==null)?ang:alpha*ang+(1-alpha)*angleSmooth;

    let now=performance.now();
    if(now-lastAngleUpdate>angleCooldown){
      angleLabel.textContent="Angle: "+angleSmooth.toFixed(1)+"째";
      lastAngleUpdate=now;
    }

    // draw points + lines always
    ctx.strokeStyle="yellow"; ctx.lineWidth=5;
    ctx.beginPath();
    ctx.moveTo(points[0].x,points[0].y);
    ctx.lineTo(points[1].x,points[1].y);
    ctx.lineTo(points[2].x,points[2].y);
    ctx.stroke();

    for(let p of points){
      ctx.fillStyle="red"; ctx.beginPath();
      ctx.arc(p.x,p.y,14,0,2*Math.PI); ctx.fill();
      ctx.fillStyle="white"; ctx.font="26px sans-serif";
      ctx.fillText(p.label,p.x+18,p.y+10);
    }

    pNext.copyTo(pPrev);
    grayCurr.copyTo(grayPrev);
    frame.delete();
    return requestAnimationFrame(render);
  }
}

function wait(){ if(typeof cv==="undefined") requestAnimationFrame(wait); else requestAnimationFrame(render); }
wait();
</script>
</body>
</html>
