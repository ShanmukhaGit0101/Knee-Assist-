<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Knee Angle Tracker</title>
<style>
body {
  margin:0;
  overflow:hidden;
  background:black;
  touch-action:none;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}
#video {
  position:absolute;
  top:0; left:0;
  width:100vw; height:100vh;
  object-fit:cover;
}
#canvas {
  position:absolute;
  top:0; left:0;
  width:100vw;
  height:100vh;
}
#angleLabel {
  position:absolute;
  top:20px;
  width:100vw;
  text-align:center;
  font-size:38px;
  font-weight:700;
  padding:14px 0;
  color:white;
  background:rgba(0,0,0,0.55);
  border-radius:8px;
  z-index:3;
}
#btnPanel {
  position:absolute;
  bottom:120px;
  width:100vw;
  display:flex;
  justify-content:center;
  flex-wrap:wrap;
  gap:18px;
  z-index:4;
}
#btnPanel button {
  padding:20px 32px;
  font-size:28px;
  font-weight:600;
  border-radius:12px;
  min-width:170px;
  background:#222;
  color:white;
  border:2px solid #555;
  cursor:pointer;
}
#btnPanel button:active {
  background:#333;
}
#startPanel {
  position:absolute;
  bottom:22px;
  width:100vw;
  display:flex;
  justify-content:center;
  z-index:5;
}
#startPanel button {
  padding:22px 34px;
  font-size:30px;
  font-weight:700;
  border-radius:12px;
  min-width:260px;
  background:#0070ff;
  color:white;
  border:none;
  cursor:pointer;
}
#startPanel button:active {
  background:#0060dd;
}
.hidden {
  display:none !important;
}
</style>
</head>
<body>

<video id="video" autoplay playsinline muted></video>
<canvas id="canvas"></canvas>
<div id="angleLabel">Angle: --째</div>

<div id="btnPanel" class="hidden">
  <button id="fixBtn">Fix</button>
  <button id="snapBtn">Snap</button>
  <button id="resetBtn">Reset</button>
  <button id="flipBtn">Flip</button>
</div>

<div id="startPanel">
  <button id="startBtn">Start Camera</button>
</div>

<script src="https://docs.opencv.org/4.5.2/opencv.js"></script>
<script>
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const angleLabel = document.getElementById("angleLabel");

const startBtn = document.getElementById("startBtn");
const fixBtn = document.getElementById("fixBtn");
const resetBtn = document.getElementById("resetBtn");
const snapBtn = document.getElementById("snapBtn");
const flipBtn = document.getElementById("flipBtn");
const btnPanel = document.getElementById("btnPanel");
const startPanel = document.getElementById("startPanel");

// ---- State ----
let placement = true;
let tracking = false;
let points = [];
let dragging = null;
let cvReady = false;

// ---- Camera ----
let videoInputs = [];
let currentCam = 0;
let stream = null;

// ---- LK Tracking ----
let grayPrev = null, grayCurr = null, pPrev = null;
let angleSmooth = null;
const alpha = 0.25;
let lastAngleUpdate = 0;
const angleCooldown = 100; // Reduced for more responsive updates

// ---- OpenCV Ready Check ----
function waitForOpenCV() {
  return new Promise((resolve) => {
    if (typeof cv !== 'undefined' && cv.Mat) {
      resolve();
    } else {
      setTimeout(() => waitForOpenCV().then(resolve), 100);
    }
  });
}

// ---- Filename ----
function timestampName() {
  const d = new Date();
  const pad = n => n.toString().padStart(2, '0');
  return `knee_${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}.png`;
}

// ---- Camera Handling ----
async function listCams() {
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    videoInputs = devices.filter(d => d.kind === "videoinput");
    // Prefer back camera on mobile
    videoInputs.sort((a, b) => {
      const aBack = a.label.toLowerCase().includes("back") ? 1 : 0;
      const bBack = b.label.toLowerCase().includes("back") ? 1 : 0;
      return bBack - aBack;
    });
  } catch (err) {
    console.error("Error listing cameras:", err);
  }
}

async function startCam() {
  try {
    if (stream) {
      stream.getTracks().forEach(t => t.stop());
    }
    
    const constraints = videoInputs.length > 0 && videoInputs[currentCam]
      ? { video: { deviceId: { exact: videoInputs[currentCam].deviceId } }, audio: false }
      : { video: { facingMode: "environment" }, audio: false };
    
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    
    // Wait for video to be ready
    await new Promise((resolve) => {
      video.onloadedmetadata = () => {
        video.play();
        resolve();
      };
    });
    
    startPanel.classList.add("hidden");
    btnPanel.classList.remove("hidden");
    resize();
  } catch (err) {
    console.error("Error starting camera:", err);
    alert("Camera access denied or unavailable. Please grant camera permissions.");
  }
}

flipBtn.onclick = async () => {
  if (videoInputs.length > 1) {
    currentCam = (currentCam + 1) % videoInputs.length;
    await startCam();
    // Reset tracking when flipping camera
    if (tracking) {
      resetTracking();
    }
  }
};

startBtn.onclick = async () => {
  await listCams();
  await startCam();
};

// ---- Auto-start camera ----
async function autoStartCamera() {
  await waitForOpenCV();
  cvReady = true;
  await listCams();
  // Try to auto-start, but don't force it if it fails
  try {
    await startCam();
  } catch (err) {
    // If auto-start fails, user needs to click the button
    console.log("Auto-start failed, waiting for user action");
  }
}

// ---- Canvas ----
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.onresize = resize;

// ---- Angle Calculation ----
function calcAngle(A, B, C) {
  const v1 = { x: A.x - B.x, y: A.y - B.y };
  const v2 = { x: C.x - B.x, y: C.y - B.y };
  const dot = v1.x * v2.x + v1.y * v2.y;
  const m1 = Math.hypot(v1.x, v1.y);
  const m2 = Math.hypot(v2.x, v2.y);
  if (m1 === 0 || m2 === 0) return 0;
  const cosAngle = Math.max(-1, Math.min(1, dot / (m1 * m2))); // Clamp for accuracy
  return Math.acos(cosAngle) * 180 / Math.PI;
}

// ---- Touch Handling ----
function getTouch(e) {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const t = e.touches[0];
  return { x: t.clientX - rect.left, y: t.clientY - rect.top };
}

canvas.addEventListener("touchstart", e => {
  if (!placement) return;
  const p = getTouch(e);
  
  // Check if touching existing point
  for (let q of points) {
    if (Math.hypot(p.x - q.x, p.y - q.y) < 40) {
      dragging = q;
      return;
    }
  }
  
  // Add new point if less than 3
  if (points.length < 3) {
    const labels = ["A", "B", "C"];
    points.push({ x: p.x, y: p.y, label: labels[points.length] });
  }
});

canvas.addEventListener("touchmove", e => {
  if (!placement || !dragging) return;
  const p = getTouch(e);
  dragging.x = p.x;
  dragging.y = p.y;
});

canvas.addEventListener("touchend", () => {
  dragging = null;
});

// ---- Fix -> Start Tracking ----
fixBtn.onclick = () => {
  if (points.length !== 3 || tracking || !cvReady) return;
  placement = false;
  tracking = true;
  
  // Initialize OpenCV matrices
  grayPrev = new cv.Mat();
  grayCurr = new cv.Mat();
  pPrev = cv.matFromArray(3, 1, cv.CV_32FC2, points.flatMap(p => [p.x, p.y]));
};

// ---- Reset Tracking ----
function resetTracking() {
  tracking = false;
  placement = true;
  points = [];
  dragging = null;
  angleSmooth = null;
  lastAngleUpdate = 0;
  
  // Clean up OpenCV matrices
  if (pPrev) { pPrev.delete(); pPrev = null; }
  if (grayPrev) { grayPrev.delete(); grayPrev = null; }
  if (grayCurr) { grayCurr.delete(); grayCurr = null; }
  
  angleLabel.textContent = "Angle: --째";
}

resetBtn.onclick = resetTracking;

// ---- Snapshot ----
snapBtn.onclick = () => {
  const sc = document.createElement("canvas");
  sc.width = canvas.width;
  sc.height = canvas.height;
  const sctx = sc.getContext("2d");
  
  // Draw video frame
  sctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  
  // Draw overlay
  sctx.drawImage(canvas, 0, 0);
  
  // Draw angle text
  sctx.font = "bold 38px sans-serif";
  sctx.fillStyle = "white";
  sctx.strokeStyle = "black";
  sctx.lineWidth = 3;
  const text = angleLabel.textContent;
  const textWidth = sctx.measureText(text).width;
  const x = (canvas.width - textWidth) / 2;
  sctx.strokeText(text, x, 60);
  sctx.fillText(text, x, 60);
  
  // Download
  const a = document.createElement("a");
  a.href = sc.toDataURL("image/png");
  a.download = timestampName();
  a.click();
};

// ---- Render Loop ----
function render() {
  if (!cvReady) {
    requestAnimationFrame(render);
    return;
  }
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // ---- Placement Mode ----
  if (placement && !tracking) {
    if (points.length === 3) {
      // Draw lines
      ctx.strokeStyle = "yellow";
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      ctx.lineTo(points[1].x, points[1].y);
      ctx.lineTo(points[2].x, points[2].y);
      ctx.stroke();
      
      // Calculate and display angle
      const angle = calcAngle(points[0], points[1], points[2]);
      angleLabel.textContent = "Angle: " + angle.toFixed(1) + "째";
    }
    
    // Draw points
    for (let p of points) {
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(p.x, p.y, 14, 0, 2 * Math.PI);
      ctx.fill();
      
      ctx.fillStyle = "white";
      ctx.font = "bold 28px sans-serif";
      ctx.fillText(p.label, p.x + 18, p.y + 10);
    }
    
    requestAnimationFrame(render);
    return;
  }

  // ---- Tracking Mode ----
  if (tracking && video.readyState === video.HAVE_ENOUGH_DATA) {
    let frame = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
    let cap = new cv.VideoCapture(video);
    cap.read(frame);
    
    // Convert to grayscale
    cv.cvtColor(frame, grayCurr, cv.COLOR_RGBA2GRAY);

    // Initialize on first tracking frame
    if (!grayPrev.cols) {
      grayCurr.copyTo(grayPrev);
      frame.delete();
      
      // Draw initial points
      drawTrackingOverlay();
      
      requestAnimationFrame(render);
      return;
    }

    // Optical flow tracking
    let pNext = new cv.Mat();
    let st = new cv.Mat();
    let err = new cv.Mat();
    
    try {
      cv.calcOpticalFlowPyrLK(
        grayPrev,
        grayCurr,
        pPrev,
        pNext,
        st,
        err,
        new cv.Size(21, 21),
        3
      );
      
      // Update points from tracking
      const arr = pNext.data32F;
      points = [
        { x: arr[0], y: arr[1], label: "A" },
        { x: arr[2], y: arr[3], label: "B" },
        { x: arr[4], y: arr[5], label: "C" }
      ];

      // Calculate angle with smoothing
      const ang = calcAngle(points[0], points[1], points[2]);
      angleSmooth = (angleSmooth == null) ? ang : alpha * ang + (1 - alpha) * angleSmooth;

      // Update display
      const now = performance.now();
      if (now - lastAngleUpdate > angleCooldown) {
        angleLabel.textContent = "Angle: " + angleSmooth.toFixed(1) + "째";
        lastAngleUpdate = now;
      }

      // Update matrices for next frame
      pNext.copyTo(pPrev);
      grayCurr.copyTo(grayPrev);
      
      // Clean up
      pNext.delete();
      st.delete();
      err.delete();
    } catch (err) {
      console.error("Tracking error:", err);
    }
    
    frame.delete();
    
    // Draw overlay
    drawTrackingOverlay();
  }

  requestAnimationFrame(render);
}

function drawTrackingOverlay() {
  // Draw lines
  ctx.strokeStyle = "yellow";
  ctx.lineWidth = 5;
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  ctx.lineTo(points[1].x, points[1].y);
  ctx.lineTo(points[2].x, points[2].y);
  ctx.stroke();

  // Draw points
  for (let p of points) {
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(p.x, p.y, 14, 0, 2 * Math.PI);
    ctx.fill();
    
    ctx.fillStyle = "white";
    ctx.font = "bold 26px sans-serif";
    ctx.fillText(p.label, p.x + 18, p.y + 10);
  }
}

// ---- Initialize ----
autoStartCamera();
render();
</script>
</body>
</html>
