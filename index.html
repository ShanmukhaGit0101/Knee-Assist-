<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Knee Angle Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            overflow: hidden;
            touch-action: none;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #videoContainer {
            position: relative;
            width: 100%;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }

        #video {
            display: none;
            max-width: 100%;
            max-height: 100%;
        }

        #canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            touch-action: none;
        }

        #angleDisplay {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: 600;
            color: #ffffff;
            background: rgba(0, 0, 0, 0.65);
            padding: 8px 20px;
            border-radius: 6px;
            z-index: 10;
            font-variant-numeric: tabular-nums;
            letter-spacing: 1px;
        }

        #controls {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 5;
        }

        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        button {
            padding: 14px;
            font-size: 15px;
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s;
            touch-action: manipulation;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }

        button:active {
            transform: scale(0.97);
            background: rgba(255, 255, 255, 0.15);
        }

        #fixBtn:not(:disabled) {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.2);
        }

        #snapBtn:not(:disabled) {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.2);
        }

        #resetBtn:not(:disabled) {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.2);
        }

        #flipBtn:not(:disabled) {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.2);
        }

        #startBtn:not(:disabled) {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.25);
            grid-column: 1 / -1;
        }

        button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        #status {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.85);
            background: rgba(0, 0, 0, 0.6);
            padding: 6px 14px;
            border-radius: 4px;
            font-size: 13px;
            z-index: 10;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="videoContainer">
            <video id="video" playsinline autoplay></video>
            <canvas id="canvas"></canvas>
            <div id="angleDisplay">--째</div>
            <div id="status">Tap Start Camera</div>
        </div>

        <div id="controls">
            <div class="button-grid">
                <button id="fixBtn" disabled>Fix</button>
                <button id="snapBtn" disabled>Snap</button>
                <button id="resetBtn" disabled>Reset</button>
                <button id="flipBtn" disabled>Flip</button>
                <button id="startBtn">Start Camera</button>
            </div>
        </div>
    </div>

    <script async src="https://docs.opencv.org/4.5.0/opencv.js"></script>
    <script>
        // State machine
        const STATE = {
            START: 0,
            PLACEMENT: 1,
            TRACKING: 2
        };

        let currentState = STATE.START;
        let points = [];
        let stream = null;
        let useFrontCamera = false;
        let tracking = false;
        let prevGray = null;
        let trackPoints = null;
        let animationId = null;
        let drawLoopId = null;
        let lastAngleUpdate = 0;
        let smoothedAngle = null;
        const ANGLE_UPDATE_INTERVAL = 500;
        const EMA_ALPHA = 0.3;

        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const angleDisplay = document.getElementById('angleDisplay');
        const status = document.getElementById('status');

        const startBtn = document.getElementById('startBtn');
        const fixBtn = document.getElementById('fixBtn');
        const snapBtn = document.getElementById('snapBtn');
        const resetBtn = document.getElementById('resetBtn');
        const flipBtn = document.getElementById('flipBtn');

        let dragIndex = -1;

        // Wait for OpenCV to load
        function onOpenCvReady() {
            console.log('OpenCV.js loaded');
        }

        // Start camera
        async function startCamera() {
            try {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }

                const constraints = {
                    video: {
                        facingMode: useFrontCamera ? 'user' : 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                await video.play();
                
                // Set canvas size to match video
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                video.style.display = 'block';

                currentState = STATE.PLACEMENT;
                updateStatus('Tap to place 3 points (A, B, C)');
                updateButtons();
                startDrawLoop();
            } catch (err) {
                console.error('Camera error:', err);
                updateStatus('Camera access denied');
            }
        }

        // Canvas interaction
        function getCanvasCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        canvas.addEventListener('touchstart', handlePointerDown);
        canvas.addEventListener('mousedown', handlePointerDown);

        function handlePointerDown(e) {
            e.preventDefault();
            if (currentState !== STATE.PLACEMENT) return;

            const coords = getCanvasCoords(e);

            // Check if clicking near existing point
            dragIndex = -1;
            for (let i = 0; i < points.length; i++) {
                const dx = points[i].x - coords.x;
                const dy = points[i].y - coords.y;
                if (Math.sqrt(dx*dx + dy*dy) < 30) {
                    dragIndex = i;
                    break;
                }
            }

            if (dragIndex === -1 && points.length < 3) {
                points.push(coords);
                updateStatus(`Point ${points.length}/3 placed`);
                if (points.length === 3) {
                    updateStatus('Drag to adjust, then press Fix');
                }
                updateButtons();
            }
        }

        canvas.addEventListener('touchmove', handlePointerMove);
        canvas.addEventListener('mousemove', handlePointerMove);

        function handlePointerMove(e) {
            e.preventDefault();
            if (currentState !== STATE.PLACEMENT || dragIndex === -1) return;

            const coords = getCanvasCoords(e);
            points[dragIndex] = coords;
        }

        canvas.addEventListener('touchend', handlePointerUp);
        canvas.addEventListener('mouseup', handlePointerUp);

        function handlePointerUp(e) {
            dragIndex = -1;
        }

        // Calculate angle
        function calculateAngle(a, b, c) {
            const ba = { x: a.x - b.x, y: a.y - b.y };
            const bc = { x: c.x - b.x, y: c.y - b.y };
            
            const dot = ba.x * bc.x + ba.y * bc.y;
            const magBA = Math.sqrt(ba.x * ba.x + ba.y * ba.y);
            const magBC = Math.sqrt(bc.x * bc.x + bc.y * bc.y);
            
            const cosAngle = dot / (magBA * magBC);
            const angle = Math.acos(Math.max(-1, Math.min(1, cosAngle)));
            
            return angle * (180 / Math.PI);
        }

        // Draw on canvas - ALWAYS draws points and lines
        function draw() {
            if (!video.videoWidth) return;

            // Draw video frame
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // ALWAYS draw points and lines if they exist (during placement AND tracking)
            if (points.length > 0) {
                // Draw lines
                if (points.length >= 2) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 4;
                    
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[1].x, points[1].y);
                    ctx.stroke();
                }
                
                if (points.length === 3) {
                    ctx.beginPath();
                    ctx.moveTo(points[1].x, points[1].y);
                    ctx.lineTo(points[2].x, points[2].y);
                    ctx.stroke();
                }

                ctx.shadowBlur = 0;

                // Draw points
                const labels = ['A', 'B', 'C'];
                points.forEach((pt, i) => {
                    // Outer circle (shadow)
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.beginPath();
                    ctx.arc(pt.x + 1, pt.y + 1, 7, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Inner circle
                    ctx.fillStyle = i === 1 ? '#ffffff' : '#ffffff';
                    ctx.beginPath();
                    ctx.arc(pt.x, pt.y, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Center dot
                    ctx.fillStyle = i === 1 ? '#000000' : '#000000';
                    ctx.beginPath();
                    ctx.arc(pt.x, pt.y, 2, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Label
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px Arial';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(labels[i], pt.x + 12, pt.y - 8);
                    ctx.fillText(labels[i], pt.x + 12, pt.y - 8);
                });

                // Update angle display
                if (points.length === 3) {
                    const now = Date.now();
                    if (currentState === STATE.TRACKING && now - lastAngleUpdate > ANGLE_UPDATE_INTERVAL) {
                        const angle = calculateAngle(points[0], points[1], points[2]);
                        
                        if (smoothedAngle === null) {
                            smoothedAngle = angle;
                        } else {
                            smoothedAngle = EMA_ALPHA * angle + (1 - EMA_ALPHA) * smoothedAngle;
                        }
                        
                        angleDisplay.textContent = smoothedAngle.toFixed(1) + '째';
                        lastAngleUpdate = now;
                    } else if (currentState === STATE.PLACEMENT) {
                        const angle = calculateAngle(points[0], points[1], points[2]);
                        angleDisplay.textContent = angle.toFixed(1) + '째';
                    }
                }
            }
        }

        // Tracking with OpenCV Lucas-Kanade
        function startTracking() {
            if (!window.cv) {
                alert('OpenCV not loaded yet. Please wait and try again.');
                return;
            }

            tracking = true;
            currentState = STATE.TRACKING;
            smoothedAngle = null;
            updateStatus('Tracking...');
            updateButtons();

            // Initialize tracking points
            const mat = new cv.Mat(points.length, 1, cv.CV_32FC2);
            for (let i = 0; i < points.length; i++) {
                mat.data32F[i * 2] = points[i].x;
                mat.data32F[i * 2 + 1] = points[i].y;
            }
            trackPoints = mat;

            // Get initial frame
            const src = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC4);
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(video, 0, 0);
            const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
            src.data.set(imageData.data);
            
            prevGray = new cv.Mat();
            cv.cvtColor(src, prevGray, cv.COLOR_RGBA2GRAY);
            src.delete();

            track();
        }

        function track() {
            if (!tracking) return;

            // Get current frame
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(video, 0, 0);
            
            const src = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC4);
            const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
            src.data.set(imageData.data);

            const gray = new cv.Mat();
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

            const nextPts = new cv.Mat();
            const status = new cv.Mat();
            const err = new cv.Mat();

            cv.calcOpticalFlowPyrLK(
                prevGray,
                gray,
                trackPoints,
                nextPts,
                status,
                err,
                new cv.Size(21, 21),
                3
            );

            // Update points based on tracking
            for (let i = 0; i < points.length; i++) {
                if (status.data[i] === 1) {
                    points[i].x = nextPts.data32F[i * 2];
                    points[i].y = nextPts.data32F[i * 2 + 1];
                }
            }

            prevGray.delete();
            prevGray = gray;
            trackPoints.delete();
            trackPoints = nextPts;
            status.delete();
            err.delete();
            src.delete();

            animationId = requestAnimationFrame(track);
        }

        function stopTracking() {
            tracking = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            if (prevGray) prevGray.delete();
            if (trackPoints) trackPoints.delete();
        }

        // Drawing loop - separate from tracking
        function startDrawLoop() {
            function loop() {
                draw();
                drawLoopId = requestAnimationFrame(loop);
            }
            loop();
        }

        // Button handlers
        startBtn.addEventListener('click', () => {
            startCamera();
        });

        fixBtn.addEventListener('click', () => {
            if (points.length === 3) {
                startTracking();
            }
        });

        snapBtn.addEventListener('click', () => {
            const timestamp = new Date().toISOString()
                .replace(/T/, '_')
                .replace(/:/g, '-')
                .split('.')[0];
            
            const link = document.createElement('a');
            link.download = `knee_${timestamp}.png`;
            link.href = canvas.toDataURL();
            link.click();
            
            updateStatus('Snapshot saved!');
            setTimeout(() => updateStatus(tracking ? 'Tracking...' : 'Place 3 points'), 2000);
        });

        resetBtn.addEventListener('click', () => {
            stopTracking();
            points = [];
            smoothedAngle = null;
            angleDisplay.textContent = '--째';
            currentState = STATE.PLACEMENT;
            updateStatus('Tap to place 3 points (A, B, C)');
            updateButtons();
        });

        flipBtn.addEventListener('click', async () => {
            useFrontCamera = !useFrontCamera;
            const wasTracking = tracking;
            const savedPoints = [...points];
            
            stopTracking();
            await startCamera();
            
            points = savedPoints;
            if (wasTracking && points.length === 3) {
                startTracking();
            }
        });

        function updateButtons() {
            fixBtn.disabled = currentState !== STATE.PLACEMENT || points.length !== 3;
            snapBtn.disabled = currentState === STATE.START || points.length === 0;
            resetBtn.disabled = currentState === STATE.START || points.length === 0;
            flipBtn.disabled = currentState === STATE.START;
            startBtn.disabled = currentState !== STATE.START;
        }

        function updateStatus(text) {
            status.textContent = text;
        }

        updateButtons();
    </script>
</body>
</html>
